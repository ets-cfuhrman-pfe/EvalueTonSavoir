name: Promote Staging to Production

on:
  workflow_dispatch:
    inputs:
      package:
        description: 'Which package to promote'
        required: true
        default: client
        type: choice
        options:
          - client
          - server
      rc_version:
        description: 'RC version to promote (e.g., 0.0.6-rc.0)'
        required: true
        type: string

jobs:
  promote-rc:
    runs-on: ubuntu-latest
    # Only allow running from main branch
    if: github.ref == 'refs/heads/main'
    outputs:
      PROD_VERSION: ${{ steps.version.outputs.PROD_VERSION }}
      PACKAGE: ${{ steps.version.outputs.PACKAGE }}
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_ORG_PAT }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Configure Git
        run: |
          git config user.name "${{ secrets.GH_ORG_NAME }}"
          git config user.email "${{ secrets.GH_ORG_EMAIL }}"
      
      - name: Validate RC version and calculate production version
        id: version
        run: |
          PACKAGE="${{ github.event.inputs.package }}"
          RC_VERSION="${{ github.event.inputs.rc_version }}"
          
          # Validate RC version format
          if [[ ! "$RC_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+-rc\.[0-9]+$ ]]; then
            echo "Error: Invalid RC version format. Expected format: X.Y.Z-rc.N"
            exit 1
          fi
          
          # Strip -rc.X suffix to get production version
          PROD_VERSION="${RC_VERSION%-rc.*}"
          
          RC_TAG="${PACKAGE}-v${RC_VERSION}"
          PROD_TAG="${PACKAGE}-v${PROD_VERSION}"
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          
          # Map package to Docker image name
          if [ "$PACKAGE" = "client" ]; then
            PACKAGE_NAME="frontend"
          else
            PACKAGE_NAME="backend"
          fi
          
          # Verify the RC tag exists
          if ! git rev-parse "$RC_TAG" >/dev/null 2>&1; then
            echo "Error: RC tag '$RC_TAG' does not exist"
            exit 1
          fi
          
          echo "RC_VERSION=${RC_VERSION}" >> $GITHUB_OUTPUT
          echo "PROD_VERSION=${PROD_VERSION}" >> $GITHUB_OUTPUT
          echo "RC_TAG=${RC_TAG}" >> $GITHUB_OUTPUT
          echo "PROD_TAG=${PROD_TAG}" >> $GITHUB_OUTPUT
          echo "PACKAGE=${PACKAGE}" >> $GITHUB_OUTPUT
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_OUTPUT
          echo "REPO_LOWER=${REPO_LOWER}" >> $GITHUB_OUTPUT
      
      - name: Install dependencies
        run: |
          cd ${{ github.event.inputs.package }}
          npm ci
      
      - name: Update package.json to production version
        run: |
          cd ${{ github.event.inputs.package }}
          npm version ${{ steps.version.outputs.PROD_VERSION }} --git-tag-version=false
      
      - name: Commit version bump
        run: |
          git add ${{ github.event.inputs.package }}/package.json
          git add ${{ github.event.inputs.package }}/package-lock.json
          git commit -m "chore(${{ steps.version.outputs.PACKAGE }}): release ${{ steps.version.outputs.PROD_VERSION }} [skip ci]"
      
      - name: Create Git tag
        run: |
          git tag ${{ steps.version.outputs.PROD_TAG }}
      
      - name: Set remote URL for push
        run: |
          git remote set-url origin https://x-access-token:${{ secrets.GH_ORG_PAT }}@github.com/ets-cfuhrman-pfe/EvalueTonSavoir.git
      
      - name: Push changes and tags
        run: |
          git push origin main
          git push origin ${{ steps.version.outputs.PROD_TAG }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GH_ORG_NAME }}
          password: ${{ secrets.GH_ORG_PAT }}

      - name: Build & push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.event.inputs.package == 'client' && '.' || 'server' }}
          file: ${{ github.event.inputs.package == 'client' && 'client/Dockerfile' || 'server/Dockerfile' }}
          push: true
          platforms: linux/amd64
          tags: |
            ghcr.io/${{ steps.version.outputs.REPO_LOWER }}-${{ steps.version.outputs.PACKAGE_NAME }}:${{ steps.version.outputs.PROD_VERSION }}
            ghcr.io/${{ steps.version.outputs.REPO_LOWER }}-${{ steps.version.outputs.PACKAGE_NAME }}:prod-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Create GitHub Release (Production)
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.PROD_TAG }}
          name: "${{ steps.version.outputs.PACKAGE }} ${{ steps.version.outputs.PROD_VERSION }}"
          body: |
            Production release for ${{ steps.version.outputs.PACKAGE }}
            
            **Version:** ${{ steps.version.outputs.PROD_VERSION }}
            **Promoted from:** ${{ steps.version.outputs.RC_VERSION }}
            **Docker Image:** `ghcr.io/${{ steps.version.outputs.REPO_LOWER }}-${{ steps.version.outputs.PACKAGE_NAME }}:${{ steps.version.outputs.PROD_VERSION }}`
            **Branch:** main
            
            This release was promoted from RC tag `${{ steps.version.outputs.RC_TAG }}`.
          prerelease: false
          draft: false

  sync-staging:
    needs: promote-rc
    runs-on: ubuntu-latest
    if: success()
    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GH_ORG_PAT }}

      - name: Configure Git
        run: |
          git config user.name "${{ secrets.GH_ORG_NAME }}"
          git config user.email "${{ secrets.GH_ORG_EMAIL }}"

      - name: Merge main into staging
        run: |
          git fetch origin main
          
          # Try to merge. If it fails, we handle conflicts.
          if ! git merge origin/main; then
            echo "Merge conflict detected. Resolving version conflicts..."
            
            PACKAGE="${{ needs.promote-rc.outputs.PACKAGE }}"
            PROD_VERSION="${{ needs.promote-rc.outputs.PROD_VERSION }}"
            
            # We assume conflicts are only in package.json/lock.json due to version
            # We keep 'ours' (staging) content for dependencies etc, but update version to match main
            
            git checkout --ours $PACKAGE/package.json
            git checkout --ours $PACKAGE/package-lock.json
            
            # Update version in package.json
            node -e "
              const fs = require('fs');
              const pkg = require('./$PACKAGE/package.json');
              pkg.version = '$PROD_VERSION';
              fs.writeFileSync('./$PACKAGE/package.json', JSON.stringify(pkg, null, 2) + '\n');
            "
            
            # Update package-lock.json version
            node -e "
              const fs = require('fs');
              const pkgLock = require('./$PACKAGE/package-lock.json');
              pkgLock.version = '$PROD_VERSION';
              pkgLock.packages[''].version = '$PROD_VERSION';
              fs.writeFileSync('./$PACKAGE/package-lock.json', JSON.stringify(pkgLock, null, 2) + '\n');
            "
            
            git add $PACKAGE/package.json $PACKAGE/package-lock.json
            
            # Check if there are other conflicts
            if git diff --name-only --diff-filter=U | grep .; then
              echo "Error: Unresolved conflicts in other files!"
              exit 1
            fi
            
            git commit -m "chore: sync release version $PROD_VERSION from main"
          fi
          
          git push origin staging
